#include<stdio.h>
#include<string.h>

//大端、小端的判定 

//大端小端是指不同的字节顺序储存方式 
//大端-数据的高位字节储存在内存的低地址中，低位字节储存在高地址中
//小端-数据的高位字节储存在内存的高地址中，低位字节储存在低地址中
//int main()
//{
//	int a = 1;//计算机内存中存放的都是补码 正数原码反码补码都相同
//	//0000 0000 0000 0000 0000 0000 0000 0001
//	//0x00 00 00 01
//	char* p= (char*)&a;//(char*)将a的地址强制转化为char型 char*类型只有一个字节
//	//指针类型的意义1.指针类型决定了指针解引用操作符能访问几个字节 -char*p *p访问了1个字节 int*p *p访问了4个字节
//	//2.指针类型决定了指针操作+1 -1加的或减得是几个字节 - char*p p+1跳过一个字节 int*p p+1跳过一个整型4个字节
//	if (*p == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("小端\n");
//	}
//	return 0;
//
//}

//函数版；
//int chek_sys()
//{
//	int a = 1;
//	return *(char*)&a;
//}
//int main()
//{
//	int ret = chek_sys();
//	if (ret = 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//}

//输出差异
//int main()
//{
//	char a = -1;
//	//10000000 00000000 00000000 00000001-原码
//	//11111111 11111111 11111111 11111110-反码
//	//11111111 11111111 11111111 11111111-补码
//	//char型只能储存8个bit位一个字节 所以char a 拿到的是11111111（这是最后面的一个字节） 但是会发生整型提升补符号位
//	//11111111 11111111 11111111 11111111 所以最后输出-1
//	signed char b = -1;
//	//与上一致
//	unsigned char c = -1;
//	//11111111 11111111 11111111 11111111-补码
//	//char a 取11111111 但整型提升时unsigned认为无符号所以补0
//	//00000000 00000000 00000000 11111111 所以最后输出255
//	printf("a=%d,b=%d,c=%d,", a, b, c);//-1，-1，255
//	return 0;
//}



//int main()
//{
//	char a = -128;
//	//10000000 000000000 00000000 10000000-原码
//	//11111111 111111111 11111111 01111111-反码
//	//11111111 111111111 11111111 10000000-补码
//	//char a 里面放的是10000000
//	//%u-打印十进制的无符号数字
//	//整型提升时会被认为是无符号类型
//	//00000000 00000000 000000000 10000000-提升后的补码
//	//输出应输出原码 但是正数原码反码补码相同所以直接输出
//	printf("%u\n", a);//4294967168	
//	return 0;
//}


//int main()
//{
//	char a[1000];
//	int i;//i为0~999
//	for (i = 0; i <= 1000; i++)
//	{
//		a[i] = -1 - i;//表面上这里应该输出-1~-1000
//		//按理说strlrn找不到\0或0应该会返回随机值但是char型的范围是-128~127这中间不在范围的这部分数会转化
//		//-1~-128.127.126.125.....2.1.0.-1.-2.........当取到0时是第255个数 所以输出255
//	}
//	printf("%d", strlen(a));//255
//	return 0;
//}